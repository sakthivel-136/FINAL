# -*- coding: utf-8 -*-
"""mic_chat

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Ei3nfgH_cdVVbbmd-_EQurgt7s4rvQs
"""



import streamlit as st
import pandas as pd
import pickle
import os
import queue
import time
import tempfile
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import speech_recognition as sr
from gtts import gTTS
from streamlit_webrtc import webrtc_streamer, AudioProcessorBase

# Constants
VECTOR_FILE = "vectorized.pkl"
CSV_FILE = "kcet.csv"
THRESHOLD = 0.75

# Page setup
st.set_page_config(page_title="üéôÔ∏è KCET Voice ChatBot", layout="centered")
st.title("üéôÔ∏è KCET Voice ChatBot")

# ---------------- Load or Build Vectorizer ----------------
def load_or_vectorize():
    if os.path.exists(VECTOR_FILE):
        with open(VECTOR_FILE, "rb") as f:
            return pickle.load(f)
    df = pd.read_csv(CSV_FILE)
    df['Question'] = df['Question'].str.strip().str.lower()
    vectorizer = TfidfVectorizer()
    vectors = vectorizer.fit_transform(df['Question'])
    pickle.dump((vectorizer, vectors, df), open(VECTOR_FILE, "wb"))
    return vectorizer, vectors, df

vectorizer, vectors, df = load_or_vectorize()

# ---------------- Audio Recorder ----------------
audio_queue = queue.Queue()

class Recorder(AudioProcessorBase):
    def recv(self, frame):
        pcm = frame.to_ndarray()
        audio_queue.put(pcm)
        return frame

webrtc_ctx = webrtc_streamer(
    key="voice-chat",
    audio_processor_factory=Recorder,
    media_stream_constraints={"audio": True},
)

# Speech recognizer
recognizer = sr.Recognizer()

# ---------------- Chat Logic ----------------
def get_response(text):
    q = text.strip().lower()
    vec = vectorizer.transform([q])
    sim = cosine_similarity(vec, vectors)
    best = sim.max()
    idx = sim.argmax()
    if best >= THRESHOLD:
        return df.iloc[idx]["Answer"]
    return "I'm sorry, I didn't get that. Could you repeat?"

def speak(text):
    tts = gTTS(text)
    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".mp3")
    tts.save(tmp.name)
    return tmp.name

# ---------------- Main Voice Loop ----------------
if st.button("üé§ Record & Ask"):
    if webrtc_ctx.audio_receiver:
        pcm = None
        try:
            pcm = audio_queue.get(timeout=5)
        except queue.Empty:
            st.error("‚ö†Ô∏è Couldn't capture audio")
        if pcm is not None:
            audio_data = sr.AudioData(
                pcm.tobytes(), webrtc_ctx.audio_receiver.get_sampling_rate(), 2
            )
            try:
                query_text = recognizer.recognize_google(audio_data)
            except Exception:
                query_text = None

            if query_text:
                st.write(f"**üó£Ô∏è You said:** {query_text}")
                reply_text = get_response(query_text)
                st.write(f"**ü§ñ Bot:** {reply_text}")
                audio_path = speak(reply_text)
                st.audio(audio_path)
            else:
                st.error("‚ùå Could not understand audio.")
    else:
        st.error("üîá Microphone not available in this browser.")

